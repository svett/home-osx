/* --------------------------------------------------------------------------------------------
 * Copyright (c) Remy Suen. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const dockerValidator_1 = require("./dockerValidator");
const dockerAssist_1 = require("./dockerAssist");
const dockerCommands_1 = require("./dockerCommands");
const dockerHover_1 = require("./dockerHover");
const dockerMarkdown_1 = require("./dockerMarkdown");
const dockerPlainText_1 = require("./dockerPlainText");
const dockerSignatures_1 = require("./dockerSignatures");
const dockerSymbols_1 = require("./dockerSymbols");
const dockerFormatter_1 = require("./dockerFormatter");
const dockerHighlight_1 = require("./dockerHighlight");
const dockerRename_1 = require("./dockerRename");
const dockerDefinition_1 = require("./dockerDefinition");
const dockerRegistryClient_1 = require("./dockerRegistryClient");
const docker_1 = require("./docker");
let markdown = new dockerMarkdown_1.MarkdownDocumentation();
let hoverProvider = new dockerHover_1.DockerHover(markdown);
let commandsProvider = new dockerCommands_1.DockerCommands();
let symbolsProvider = new dockerSymbols_1.DockerSymbols();
let formatterProvider = new dockerFormatter_1.DockerFormatter();
let definitionProvider = new dockerDefinition_1.DockerDefinition();
let documentationResolver = new dockerPlainText_1.PlainTextDocumentation();
let signatureHelp = new dockerSignatures_1.DockerSignatures();
let validatorSettings = null;
let connection = vscode_languageserver_1.createConnection();
let dockerRegistryClient = new dockerRegistryClient_1.DockerRegistryClient(connection);
let snippetSupport = false;
let documents = {};
function supportsSnippets(capabilities) {
    return capabilities.textDocument
        && capabilities.textDocument.completion
        && capabilities.textDocument.completion.completionItem
        && capabilities.textDocument.completion.completionItem.snippetSupport;
}
connection.onInitialize((params) => {
    snippetSupport = supportsSnippets(params.capabilities);
    return {
        capabilities: {
            textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
            codeActionProvider: true,
            completionProvider: {
                resolveProvider: true,
                triggerCharacters: [
                    '=',
                    ' ',
                    '$',
                    '-',
                ]
            },
            executeCommandProvider: {
                commands: [
                    dockerCommands_1.CommandIds.LOWERCASE,
                    dockerCommands_1.CommandIds.UPPERCASE,
                    dockerCommands_1.CommandIds.EXTRA_ARGUMENT,
                    dockerCommands_1.CommandIds.DIRECTIVE_TO_BACKSLASH,
                    dockerCommands_1.CommandIds.DIRECTIVE_TO_BACKTICK,
                    dockerCommands_1.CommandIds.CONVERT_TO_AS
                ]
            },
            documentFormattingProvider: true,
            documentRangeFormattingProvider: true,
            documentOnTypeFormattingProvider: {
                firstTriggerCharacter: '\\',
                moreTriggerCharacter: ['`']
            },
            hoverProvider: true,
            documentSymbolProvider: true,
            documentHighlightProvider: true,
            renameProvider: true,
            definitionProvider: true,
            signatureHelpProvider: {
                triggerCharacters: [
                    '-',
                    '[',
                    ',',
                    ' ',
                    '='
                ]
            }
        }
    };
});
function validateTextDocument(textDocument) {
    var validator = new dockerValidator_1.Validator(validatorSettings);
    let diagnostics = validator.validate(docker_1.KEYWORDS, textDocument);
    connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}
function getSeverity(severity) {
    switch (severity) {
        case "ignore":
            return dockerValidator_1.ValidationSeverity.IGNORE;
        case "warning":
            return dockerValidator_1.ValidationSeverity.WARNING;
        case "error":
            return dockerValidator_1.ValidationSeverity.ERROR;
    }
    return null;
}
connection.onDidChangeConfiguration((change) => {
    let settings = change.settings;
    let maintainer = dockerValidator_1.ValidationSeverity.WARNING;
    let directiveCasing = dockerValidator_1.ValidationSeverity.WARNING;
    let instructionCasing = dockerValidator_1.ValidationSeverity.WARNING;
    let instructionCmdMultiple = dockerValidator_1.ValidationSeverity.WARNING;
    let instructionEntrypointMultiple = dockerValidator_1.ValidationSeverity.WARNING;
    let instructionHealthcheckMultiple = dockerValidator_1.ValidationSeverity.WARNING;
    if (settings.docker && settings.docker.languageserver && settings.docker.languageserver.diagnostics) {
        maintainer = getSeverity(settings.docker.languageserver.diagnostics.deprecatedMaintainer);
        directiveCasing = getSeverity(settings.docker.languageserver.diagnostics.directiveCasing);
        instructionCasing = getSeverity(settings.docker.languageserver.diagnostics.instructionCasing);
        instructionCmdMultiple = getSeverity(settings.docker.languageserver.diagnostics.instructionCmdMultiple);
        instructionEntrypointMultiple = getSeverity(settings.docker.languageserver.diagnostics.instructionEntrypointMultiple);
        instructionHealthcheckMultiple = getSeverity(settings.docker.languageserver.diagnostics.instructionHealthcheckMultiple);
    }
    validatorSettings = {
        deprecatedMaintainer: maintainer,
        directiveCasing: directiveCasing,
        instructionCasing: instructionCasing,
        instructionCmdMultiple: instructionCmdMultiple,
        instructionEntrypointMultiple: instructionEntrypointMultiple,
        instructionHealthcheckMultiple: instructionHealthcheckMultiple
    };
    // validate all the documents again
    Object.keys(documents).forEach((key) => {
        validateTextDocument(documents[key]);
    });
});
connection.onCompletion((textDocumentPosition) => {
    let document = documents[textDocumentPosition.textDocument.uri];
    if (document) {
        let assist = new dockerAssist_1.DockerAssist(document, snippetSupport, dockerRegistryClient);
        return assist.computeProposals(document, textDocumentPosition.position);
    }
    return null;
});
connection.onSignatureHelp((textDocumentPosition) => {
    let document = documents[textDocumentPosition.textDocument.uri];
    if (document !== null) {
        return signatureHelp.computeSignatures(document, textDocumentPosition.position);
    }
    return {
        signatures: [],
        activeSignature: null,
        activeParameter: null,
    };
});
connection.onCompletionResolve((item) => {
    if (!item.documentation) {
        item.documentation = documentationResolver.getDocumentation(item.data);
    }
    return item;
});
connection.onHover((textDocumentPosition) => {
    let document = documents[textDocumentPosition.textDocument.uri];
    if (document !== null) {
        return hoverProvider.onHover(document, textDocumentPosition);
    }
    return null;
});
connection.onDocumentHighlight((textDocumentPosition) => {
    let document = documents[textDocumentPosition.textDocument.uri];
    if (document) {
        let highlightProvider = new dockerHighlight_1.DockerHighlight();
        return highlightProvider.computeHighlightRanges(document, textDocumentPosition.position);
    }
    return [];
});
connection.onCodeAction((codeActionParams) => {
    if (codeActionParams.context.diagnostics.length > 0) {
        return commandsProvider.analyzeDiagnostics(codeActionParams.context.diagnostics, codeActionParams.textDocument.uri, codeActionParams.range);
    }
    return [];
});
connection.onExecuteCommand((params) => {
    let uri = params.arguments[0];
    let document = documents[uri];
    if (document) {
        let edit = commandsProvider.createWorkspaceEdit(document, params);
        if (edit) {
            connection.workspace.applyEdit(edit);
        }
    }
});
connection.onDefinition((textDocumentPosition) => {
    let uri = textDocumentPosition.textDocument.uri;
    let document = documents[uri];
    if (document) {
        return definitionProvider.computeDefinition(document, textDocumentPosition.position);
    }
    return null;
});
connection.onRenameRequest((params) => {
    let document = documents[params.textDocument.uri];
    if (document) {
        let rename = new dockerRename_1.DockerRename();
        let edits = rename.rename(document, params.position, params.newName);
        return {
            changes: {
                [params.textDocument.uri]: edits
            }
        };
    }
    return null;
});
connection.onDocumentSymbol((documentSymbolParams) => {
    let uri = documentSymbolParams.textDocument.uri;
    let document = documents[uri];
    if (document) {
        return symbolsProvider.parseSymbolInformation(document, uri);
    }
    return [];
});
connection.onDocumentFormatting((documentFormattingParams) => {
    let document = documents[documentFormattingParams.textDocument.uri];
    if (document) {
        return formatterProvider.formatDocument(document, documentFormattingParams.options);
    }
    return [];
});
connection.onDocumentRangeFormatting((rangeFormattingParams) => {
    let document = documents[rangeFormattingParams.textDocument.uri];
    if (document) {
        return formatterProvider.formatRange(document, rangeFormattingParams.range, rangeFormattingParams.options);
    }
    return [];
});
connection.onDocumentOnTypeFormatting((onTypeFormattingParams) => {
    const document = documents[onTypeFormattingParams.textDocument.uri];
    if (document) {
        return formatterProvider.formatOnType(document, onTypeFormattingParams.position, onTypeFormattingParams.ch, onTypeFormattingParams.options);
    }
    return [];
});
connection.onDidOpenTextDocument((didOpenTextDocumentParams) => {
    let document = vscode_languageserver_1.TextDocument.create(didOpenTextDocumentParams.textDocument.uri, didOpenTextDocumentParams.textDocument.languageId, didOpenTextDocumentParams.textDocument.version, didOpenTextDocumentParams.textDocument.text);
    documents[didOpenTextDocumentParams.textDocument.uri] = document;
    validateTextDocument(document);
});
function getLaterChange(changes, i, j) {
    if (changes[i].range.start.line === changes[j].range.start.line) {
        return changes[i].range.start.character < changes[j].range.start.character ? j : i;
    }
    else if (changes[i].range.start.line < changes[j].range.start.line) {
        return j;
    }
    return i;
}
function sortChanges(changes) {
    let sorted = [];
    let length = changes.length;
    for (let i = 0; i < length; i++) {
        let candidate = 0;
        for (let j = 1; j < changes.length; j++) {
            candidate = getLaterChange(changes, candidate, j);
        }
        sorted.push(changes[candidate]);
        changes.splice(candidate, 1);
    }
    return sorted;
}
function handleChanges(document, content, changes) {
    if (changes.length === 1 && !changes[0].range) {
        // not an incremental change
        return changes[0].text;
    }
    else if (changes.length !== 0) {
        changes = sortChanges(changes);
        for (let i = 0; i < changes.length; i++) {
            let offset = document.offsetAt(changes[i].range.start);
            let end = null;
            if (changes[i].range.end) {
                end = document.offsetAt(changes[i].range.end);
            }
            else {
                end = offset + changes[i].rangeLength;
            }
            content = content.substring(0, offset) + changes[i].text + content.substring(end);
        }
    }
    return content;
}
connection.onDidChangeTextDocument((didChangeTextDocumentParams) => {
    let document = documents[didChangeTextDocumentParams.textDocument.uri];
    let buffer = document.getText();
    let changes = didChangeTextDocumentParams.contentChanges;
    let changed = handleChanges(document, buffer, changes);
    if (changed !== buffer) {
        document = vscode_languageserver_1.TextDocument.create(didChangeTextDocumentParams.textDocument.uri, document.languageId, didChangeTextDocumentParams.textDocument.version, changed);
        documents[didChangeTextDocumentParams.textDocument.uri] = document;
        validateTextDocument(document);
    }
});
connection.onDidCloseTextDocument((didCloseTextDocumentParams) => {
    delete documents[didCloseTextDocumentParams.textDocument.uri];
});
// setup complete, start listening for a client connection
connection.listen();
